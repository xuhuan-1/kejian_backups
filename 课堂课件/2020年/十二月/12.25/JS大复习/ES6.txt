let:
    声明变量的，相当于var
    1、没有变量提升
    2、有独立作用域
    3、不允许重复声明
    4、存在暂时性死区
const:
    声明常量的，相当于var
    1、没有变量提升
    2、有独立作用域
    3、不允许重复声明
    4、存在暂时性死区

箭头函数：
    1、可以简写
        () => item == 4
        没有参数，必须写小括号，有一个可以省略小括号，有多个参数，必须
        要写小括号
        当一个箭头函数内部返回的是对象，有简写方式
        () => ({})
        剩余参数：必须写在最后
    2、没有this，借用直接上下文作用域【this】
    3、不能被实例化，不能被用做构造函数
    4、没有arguments对象

对象中可以写尾逗号

...:扩展运算符,可以降一维

class：
    ES6中的类：有了类的概念、模块化、独立作用域
             不存在函数提升
    1、是function的语法糖
    2、和构造函数没有关系
    3、类的内部默认是严格模式
    4、类的内部有个默认的constructor函数，可以声明，不声明的时候，
       累的内部会自动创建一个constructor函数
    5、静态方法：
        类自身的方法，一般情况下不会被继承，可以不实例化，直接使用
        通过类名调用
        关键字：static，代表的是静态方法
    6、原型方法：
        类添加在prototype上的方法，必须实例化，才可使用
    7、通过extends进行继承、super接收继承的数据
    8、super接收之前不能访问this，会报错
    9、super指向的是父类， 当通过extends继承的时候，super触发了父类中的constructor
       函数，父类中constructor函数携带着属性、方法等传递给子类，并且触发了子类中的
       constructor函数，将this指向子类
    10、当super以对象的方式在子类的静态方法中调用、可以继承父类中的静态方法
    11、当super以对象的方式在子类的原型方法中调用，则可以继承父类的原型方法
    
    ES2015 === ES6

Promise:
    ES6新增的异步解决方案，主要用来前后端交互，还可以用做异步方法封装

    有三种状态：
        1、pending 准备
        2、resolve 成功
        3、reject  失败
    状态不可逆： 
        只能从准备到成功或者只能从准备到失败
    
    为什么可以链式调用？
        因为then、catch函数内部都返回一个新的Promise对象

    Promise接收一个回调函数作为参数，此函数叫做函数解析器 【executor】
    executor又接收两个参数：
        第一个参数是成功的回调：resolve
        第二个参数是失败的回调：reject

    静态方法：
        race：接收一个数组作为参数，数组内是多个Promise接口，谁执行的最快，得到结果最快
             一旦得到结果，race就立马停止执行，返回一个数组，数组内是当前的执行结果
        all:接收一个数组作为参数，数组内是多个Promise接口，一定等所有的Promise执行完成
            all方法才返回结果，此结果是数组，是每一个Promise的结果
        resolve:成功的回调
        reject:失败的回调
    原型方法：
        then():成功的回调，接收两个参数，第一个是成功的回调，第二个是失败的回调，省略不写
        catch():失败的回调
        finally():不管成功还是失败，都会继续执行 【用的不多】

Generator函数：生成器函数
    可以控制函数的内部执行过程，内部原型方法上有3个函数
    next：移动指针，执行下一步
    throw：汇集错误信息的函数
    return：一旦调用，立即结束执行当前生成器函数
   函数体内部： 
      关键字：yield
             打断执行，要想重新启动执行，必须调用next方法
   返回值：
      迭代器对象：可以被for of循环，因为生成器函数具有迭代器接口
      此对象里面有两个值：
        done：布尔值，当前函数没有执行结束是未false，结束后为true
        value:每次调用next的结果

终极异步解决方案：
    async await：原理是Generator
    场景： 
        async await配合Promise进行前后端交互

    await必须在async标识内

    async await后面一般都跟的是Promise对象，可以跟异步代码

    Map:
    WeakMap:
    Set:
    WeakSet:

    proxies:代理，监听数组、对象的内部过程，可以进行拦截操作
